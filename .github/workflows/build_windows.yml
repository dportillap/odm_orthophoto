name: Build Windows Exe
on: [push, workflow_dispatch]

jobs:
  build:
    runs-on: windows-2019
    
    steps:
    - uses: actions/checkout@v4
    
    # 1. Instalamos Miniforge (SIN FORZAR VERSIÓN DE PYTHON)
    - name: Setup Miniforge
      uses: conda-incubator/setup-miniconda@v3
      with:
        miniforge-variant: Miniforge3
        miniforge-version: latest
        activate-environment: base
        # python-version: 3.9  <-- ELIMINADO PARA EVITAR CONFLICTOS
        
    # 2. Instalamos librerías EN LA BASE (Directo a la vena)
    - name: Install Dependencies
      shell: bash -l {0}
      run: |
        # Instalamos todo en el entorno base actual
        # Esto garantiza que los archivos estén en una ruta conocida
        mamba install -n base -c conda-forge cmake ninja compilers gdal opencv pcl boost eigen -y

    # 3. EL RASTREADOR ABSOLUTO (Busca dónde quedaron los archivos)
    - name: Locate and Configure
      shell: bash -l {0}
      run: |
        python -c "
        import os
        import glob
        
        # Buscamos en la raíz de la instalación de Conda
        # En GitHub Actions suele ser C:/Users/runneradmin/miniconda3
        base_search_dir = os.environ['CONDA_PREFIX'].replace('\\\\', '/')
        print(f'Escaner iniciado en: {base_search_dir}')
        
        found_includes = set()
        # Siempre añadimos src
        found_includes.add('src')
        
        pcl_found = False
        eigen_found = False
        
        # --- BUSQUEDA DE HEADERS (RECURSIVA) ---
        for root, dirs, files in os.walk(base_search_dir):
            root_norm = root.replace('\\\\', '/')
            
            # 1. BUSCAR EIGEN (StdVector)
            if not eigen_found and 'StdVector' in files:
                # El código pide <Eigen/StdVector>
                # Si encontramos .../include/eigen3/Eigen/StdVector
                if root_norm.endswith('/Eigen'):
                    # La ruta de inclusión debe ser .../include/eigen3
                    inc_path = root_norm.rsplit('/Eigen', 1)[0]
                    print(f'¡EIGEN ENCONTRADO!: {inc_path}')
                    found_includes.add(inc_path)
                    eigen_found = True

            # 2. BUSCAR PCL (obj_io.h)
            if not pcl_found and 'obj_io.h' in files:
                # El código pide <pcl/io/obj_io.h>
                # Si encontramos .../include/pcl-1.12/pcl/io/obj_io.h
                if root_norm.endswith('/pcl/io'):
                    # La ruta de inclusión debe ser .../include/pcl-1.12
                    inc_path = root_norm.rsplit('/pcl/io', 1)[0]
                    print(f'¡PCL ENCONTRADO!: {inc_path}')
                    found_includes.add(inc_path)
                    pcl_found = True
            
            # Si encontramos ambos, podemos parar de buscar headers
            if eigen_found and pcl_found:
                break
        
        # Fallback de seguridad
        if not eigen_found:
            print('WARN: No encontré Eigen, adivinando ruta...')
            found_includes.add(f'{base_search_dir}/Library/include/eigen3')
        if not pcl_found:
            print('WARN: No encontré PCL, adivinando ruta...')
            found_includes.add(f'{base_search_dir}/Library/include')

        # --- BUSQUEDA DE LIBRERIAS (.LIB) ---
        # Buscamos recursivamente porque a veces no están en Library/lib
        pcl_libs = []
        cv_libs = []
        boost_libs = []
        gdal_libs = []

        print('Buscando librerias .lib recursivamente...')
        for root, dirs, files in os.walk(base_search_dir):
            root_norm = root.replace('\\\\', '/')
            for f in files:
                if f.endswith('.lib'):
                    full_path = f'{root_norm}/{f}'
                    
                    if f.startswith('pcl_') and not f.endswith('d.lib'):
                         pcl_libs.append(full_path)
                    elif f.startswith('opencv_') and not f.endswith('d.lib'):
                         cv_libs.append(full_path)
                    elif f.startswith('boost_') and not f.endswith('d.lib'):
                         boost_libs.append(full_path)
                    elif f == 'gdal_i.lib':
                         gdal_libs.append(full_path)
        
        all_libs = pcl_libs + cv_libs + boost_libs + gdal_libs
        
        # Eliminar duplicados si los hubiera
        all_libs = list(set(all_libs))
        
        print(f'Total Librerías encontradas: {len(all_libs)}')

        # --- GENERAR CMAKELISTS.TXT ---
        # Convertimos sets/listas a strings para CMake
        inc_str = ' '.join([f'\"{p}\"' for p in found_includes])
        # Usamos replace para asegurar slash normal en Windows
        libs_str = ' '.join([f'\"{l}\"' for l in all_libs])
        
        cmake_content = f'''
        cmake_minimum_required(VERSION 3.5)
        project(odm_orthophoto)
        set(CMAKE_CXX_STANDARD 14)
        add_definitions(-D_CRT_SECURE_NO_WARNINGS -DNOMINMAX -DBOOST_USE_WINDOWS_H)
        
        # Rutas calculadas por el Rastreador
        include_directories({inc_str})
        
        add_executable(odm_orthophoto src/OdmOrthoPhoto.cpp src/Logger.cpp src/main.cpp)
        
        target_link_libraries(odm_orthophoto {libs_str})
        '''
        
        with open('CMakeLists.txt', 'w') as f:
            f.write(cmake_content)
            
        print('--- CMakeLists.txt generado ---')
        "

    # 4. COMPILACIÓN
    - name: Compile
      shell: bash -l {0}
      run: |
        mkdir build
        cd build
        cmake .. -G "Visual Studio 16 2019" -A x64 -DCMAKE_BUILD_TYPE=Release
        cmake --build . --config Release
        
    # 5. Subida
    - name: Upload Artifact
      uses: actions/upload-artifact@v4
      with:
        name: odm_orthophoto_exe
        path: build/Release/odm_orthophoto.exe
        compression-level: 0
