name: Build Windows Exe
on: [push, workflow_dispatch]

jobs:
  build:
    runs-on: windows-2019
    
    steps:
    - uses: actions/checkout@v4
    
    # 1. Instalamos Miniforge
    - name: Setup Miniforge
      uses: conda-incubator/setup-miniconda@v3
      with:
        miniforge-variant: Miniforge3
        miniforge-version: latest
        activate-environment: odm_build
        python-version: 3.9
        
    # 2. Instalamos librerías
    - name: Install Dependencies
      shell: bash -l {0}
      run: |
        mamba install -c conda-forge cmake ninja compilers gdal opencv pcl boost eigen -y

    # 3. EL RASTREADOR GPS (Busca archivos específicos)
    - name: Pinpoint Files with Python
      shell: bash -l {0}
      run: |
        python -c "
        import os
        import glob
        import sys
        
        # Función para normalizar rutas a formato Unix (que CMake ama)
        def fix_path(p):
            return os.path.abspath(p).replace('\\', '/')

        base_dir = os.environ['CONDA_PREFIX']
        print(f'Escaneando base: {base_dir}')

        # --- BUSQUEDA DE HEADERS ---
        # Buscamos 'obj_io.h' para saber dónde rayos está PCL
        pcl_include_root = ''
        for root, dirs, files in os.walk(base_dir):
            if 'obj_io.h' in files:
                # Encontramos .../include/pcl-1.X/pcl/io/obj_io.h
                # Necesitamos subir 3 niveles para obtener .../include/pcl-1.X
                path = fix_path(root)
                if path.endswith('/pcl/io'):
                     pcl_include_root = path.replace('/pcl/io', '')
                     print(f'FOUND PCL HEADER ROOT: {pcl_include_root}')
                     break
        
        # Buscamos 'StdVector' para Eigen
        eigen_include_root = ''
        for root, dirs, files in os.walk(base_dir):
            if 'StdVector' in files:
                # Eigen suele estar en .../eigen3/Eigen/StdVector
                path = fix_path(root)
                if path.endswith('/Eigen'):
                    eigen_include_root = path.replace('/Eigen', '')
                    print(f'FOUND EIGEN HEADER ROOT: {eigen_include_root}')
                    break

        if not pcl_include_root:
            print('ERROR: No pude encontrar obj_io.h')
            # Fallback desesperado
            pcl_include_root = fix_path(f'{base_dir}/Library/include')

        if not eigen_include_root:
             # Fallback
             eigen_include_root = fix_path(f'{base_dir}/Library/include/eigen3')

        # --- BUSQUEDA DE LIBRERIAS ---
        # Python hace el trabajo sucio de listar los archivos .lib
        lib_dir = fix_path(f'{base_dir}/Library/lib')
        
        # Usamos glob de Python que es más confiable
        pcl_libs = glob.glob(f'{lib_dir}/pcl_*.lib')
        opencv_libs = glob.glob(f'{lib_dir}/opencv_*.lib')
        boost_libs = glob.glob(f'{lib_dir}/boost_*.lib')
        
        # Convertimos las listas a strings separados por punto y coma (formato CMake)
        pcl_libs_str = ';'.join([fix_path(p) for p in pcl_libs])
        opencv_libs_str = ';'.join([fix_path(p) for p in opencv_libs])
        boost_libs_str = ';'.join([fix_path(p) for p in boost_libs])
        gdal_lib = fix_path(f'{lib_dir}/gdal_i.lib')

        print(f'PCL LIBS COUNT: {len(pcl_libs)}')

        # Escribimos al entorno de GitHub
        with open(os.environ['GITHUB_ENV'], 'a') as f:
            f.write(f'DETECTED_PCL_INCLUDE={pcl_include_root}\n')
            f.write(f'DETECTED_EIGEN_INCLUDE={eigen_include_root}\n')
            f.write(f'DETECTED_PCL_LIBS={pcl_libs_str}\n')
            f.write(f'DETECTED_CV_LIBS={opencv_libs_str}\n')
            f.write(f'DETECTED_BOOST_LIBS={boost_libs_str}\n')
            f.write(f'DETECTED_GDAL_LIB={gdal_lib}\n')
        "

    # 4. COMPILACIÓN QUIRÚRGICA
    - name: Compile
      shell: bash -l {0}
      run: |
        # --- GENERAMOS EL CMAKELISTS.TXT ---
        cat > CMakeLists.txt <<EOF
        cmake_minimum_required(VERSION 3.5)
        project(odm_orthophoto)
        set(CMAKE_CXX_STANDARD 14)
        
        add_definitions(-D_CRT_SECURE_NO_WARNINGS -DNOMINMAX -DBOOST_USE_WINDOWS_H)

        # 1. HEADERS DIRECTOS (Sin adivinanzas)
        include_directories("$DETECTED_PCL_INCLUDE")
        include_directories("$DETECTED_EIGEN_INCLUDE")
        include_directories("\$ENV{CONDA_PREFIX}/Library/include")
        include_directories("src")
        
        # 2. LIBRERIAS (Pasadas directamente como lista de archivos)
        # Ya no usamos GLOB aquí, usamos lo que Python encontró
        
        add_executable(odm_orthophoto src/OdmOrthoPhoto.cpp src/Logger.cpp src/main.cpp)
        
        # Enlazamos las variables de entorno directas
        target_link_libraries(odm_orthophoto 
            "$DETECTED_PCL_LIBS" 
            "$DETECTED_CV_LIBS" 
            "$DETECTED_GDAL_LIB" 
            "$DETECTED_BOOST_LIBS"
        )
        EOF
        
        # --- COMPILACIÓN ---
        mkdir build
        cd build
        
        cmake .. -G "Visual Studio 16 2019" -A x64 -DCMAKE_BUILD_TYPE=Release
        cmake --build . --config Release
        
    # 5. Subida
    - name: Upload Artifact
      uses: actions/upload-artifact@v4
      with:
        name: odm_orthophoto_exe
        path: build/Release/odm_orthophoto.exe
        compression-level: 0
