name: Build Windows Exe
on: [push, workflow_dispatch]

jobs:
  build:
    runs-on: windows-2019
    
    steps:
    - uses: actions/checkout@v4
    
    # 1. Instalamos Miniforge
    - name: Setup Miniforge
      uses: conda-incubator/setup-miniconda@v3
      with:
        miniforge-variant: Miniforge3
        miniforge-version: latest
        activate-environment: odm_build
        python-version: 3.9
        
    # 2. Instalamos librerías
    - name: Install Dependencies
      shell: bash -l {0}
      run: |
        mamba install -c conda-forge cmake ninja compilers gdal opencv pcl boost eigen -y

    # 3. EL ARQUITECTO MATEMÁTICO (Calcula las rutas restando el path relativo)
    - name: Reverse Engineer Paths
      shell: bash -l {0}
      run: |
        python -c "
        import os
        import glob
        
        base_dir = os.environ['CONDA_PREFIX'].replace('\\\\', '/')
        lib_dir = f'{base_dir}/Library/lib'
        print(f'Escaner iniciado en: {base_dir}')
        
        detected_includes = set()
        # Siempre añadimos la base y src por seguridad
        detected_includes.add(f'{base_dir}/Library/include')
        detected_includes.add('src')
        
        # --- BUSQUEDA INTELIGENTE DE HEADERS ---
        for root, dirs, files in os.walk(base_dir):
            root_norm = root.replace('\\\\', '/')
            
            # CASO 1: EIGEN
            # El codigo pide <Eigen/StdVector>
            # Buscamos el archivo 'StdVector'
            if 'StdVector' in files:
                # Si la carpeta donde lo encontramos termina en '/Eigen',
                # significa que encontramos .../RutaCorrecta/Eigen/StdVector
                if root_norm.endswith('/Eigen'):
                    # Cortamos los ultimos 6 caracteres ('/Eigen') para obtener '.../RutaCorrecta'
                    include_root = root_norm[:-6]
                    print(f'¡EIGEN ENCONTRADO! Ruta real: {root_norm}')
                    print(f' -> Include necesario: {include_root}')
                    detected_includes.add(include_root)

            # CASO 2: PCL
            # El codigo pide <pcl/io/obj_io.h>
            # Buscamos 'obj_io.h'
            if 'obj_io.h' in files:
                # Si la carpeta termina en '/pcl/io', encontramos .../RutaCorrecta/pcl/io/obj_io.h
                if root_norm.endswith('/pcl/io'):
                    # Cortamos los ultimos 7 caracteres ('/pcl/io')
                    include_root = root_norm[:-7]
                    print(f'¡PCL ENCONTRADO! Ruta real: {root_norm}')
                    print(f' -> Include necesario: {include_root}')
                    detected_includes.add(include_root)

        # Preparamos el string para CMake
        includes_str = ' '.join([f'\"{p}\"' for p in detected_includes])
        
        # --- BUSQUEDA DE LIBRERÍAS (GLOB) ---
        # Buscamos recursivamente cualquier .lib de PCL, OpenCV, Boost
        pcl_libs = []
        cv_libs = []
        boost_libs = []
        gdal_libs = []
        
        for root, dirs, files in os.walk(lib_dir):
            root_norm = root.replace('\\\\', '/')
            for f in files:
                if f.endswith('.lib'):
                    full_path = f'{root_norm}/{f}'
                    if f.startswith('pcl_') and not f.endswith('d.lib'): pcl_libs.append(full_path)
                    elif f.startswith('opencv_') and not f.endswith('d.lib'): cv_libs.append(full_path)
                    elif f.startswith('boost_') and not f.endswith('d.lib'): boost_libs.append(full_path)
                    elif f == 'gdal_i.lib': gdal_libs.append(full_path)

        all_libs = pcl_libs + cv_libs + boost_libs + gdal_libs
        all_libs_str = ' '.join([f'\"{l}\"' for l in all_libs])
        
        print(f'Total Librerias: {len(all_libs)}')

        # --- GENERAR CMAKELISTS.TXT ---
        cmake_content = f'''
        cmake_minimum_required(VERSION 3.5)
        project(odm_orthophoto)
        set(CMAKE_CXX_STANDARD 14)
        
        add_definitions(-D_CRT_SECURE_NO_WARNINGS -DNOMINMAX -DBOOST_USE_WINDOWS_H)
        
        # Inyectamos las rutas calculadas matemáticamente
        include_directories({includes_str})
        
        add_executable(odm_orthophoto src/OdmOrthoPhoto.cpp src/Logger.cpp src/main.cpp)
        
        target_link_libraries(odm_orthophoto {all_libs_str})
        '''
        
        with open('CMakeLists.txt', 'w') as f:
            f.write(cmake_content)
            
        print('--- CMakeLists.txt generado ---')
        "

    # 4. COMPILACIÓN
    - name: Compile
      shell: bash -l {0}
      run: |
        mkdir build
        cd build
        cmake .. -G "Visual Studio 16 2019" -A x64 -DCMAKE_BUILD_TYPE=Release
        cmake --build . --config Release
        
    # 5. Subida
    - name: Upload Artifact
      uses: actions/upload-artifact@v4
      with:
        name: odm_orthophoto_exe
        path: build/Release/odm_orthophoto.exe
        compression-level: 0
