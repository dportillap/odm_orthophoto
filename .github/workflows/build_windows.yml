name: Build Windows Exe
on: [push, workflow_dispatch]

jobs:
  build:
    runs-on: windows-2019
    
    steps:
    - uses: actions/checkout@v4
    
    # 1. Instalamos Miniforge
    - name: Setup Miniforge
      uses: conda-incubator/setup-miniconda@v3
      with:
        miniforge-variant: Miniforge3
        miniforge-version: latest
        activate-environment: odm_build
        python-version: 3.9
        
    # 2. Instalamos librerías (FORZANDO LA RUTA)
    - name: Install Dependencies
      shell: bash -l {0}
      run: |
        # Usamos -p $CONDA_PREFIX para obligarlo a instalar AQUI
        mamba install -p "$CONDA_PREFIX" -c conda-forge cmake ninja compilers gdal opencv pcl boost eigen -y

    # 3. EL RADAR DE LARGO ALCANCE (Busca en todo el disco de Conda)
    - name: Deep Search and Config
      shell: bash -l {0}
      run: |
        python -c "
        import os
        import glob
        
        # Obtenemos la raíz de toda la instalación de Miniconda (dos niveles arriba del env)
        env_root = os.environ['CONDA_PREFIX'].replace('\\\\', '/')
        # Si estamos en .../envs/odm_build, subir 2 niveles nos lleva a .../miniconda3
        conda_root = os.path.dirname(os.path.dirname(env_root))
        
        print(f'Buscando en TODO Conda: {conda_root}')
        
        # Variables para guardar los tesoros encontrados
        found_eigen_include = None
        found_pcl_include = None
        found_libs_dir = None # Directorio donde haya más libs
        
        libs_pcl = []
        libs_cv = []
        libs_boost = []
        lib_gdal = None
        
        # --- RECORRIDO RECURSIVO MASIVO ---
        # Esto puede tardar unos segundos pero encontrará los archivos si existen en el disco
        for root, dirs, files in os.walk(conda_root):
            root_norm = root.replace('\\\\', '/')
            
            # A. BUSCAR HEADERS
            # Eigen
            if not found_eigen_include and 'StdVector' in files:
                if root_norm.endswith('/Eigen'):
                    found_eigen_include = root_norm.rsplit('/Eigen', 1)[0]
                    print(f'¡EIGEN ENCONTRADO EN CACHÉ!: {found_eigen_include}')
            
            # PCL
            if not found_pcl_include and 'obj_io.h' in files:
                if root_norm.endswith('/pcl/io'):
                    found_pcl_include = root_norm.rsplit('/pcl/io', 1)[0]
                    print(f'¡PCL ENCONTRADO EN CACHÉ!: {found_pcl_include}')

            # B. BUSCAR LIBRERÍAS
            # Recolectamos todas las que veamos
            for f in files:
                if f.endswith('.lib'):
                    full_path = f'{root_norm}/{f}'
                    if f.startswith('pcl_io') and not f.endswith('d.lib'): # Usamos pcl_io como marcador
                         if not found_libs_dir:
                             found_libs_dir = root_norm
                             print(f'¡LIBRERÍAS DETECTADAS EN!: {found_libs_dir}')
                    
                    if f.startswith('pcl_') and not f.endswith('d.lib'): libs_pcl.append(full_path)
                    elif f.startswith('opencv_') and not f.endswith('d.lib'): libs_cv.append(full_path)
                    elif f.startswith('boost_') and not f.endswith('d.lib'): libs_boost.append(full_path)
                    elif f == 'gdal_i.lib': lib_gdal = full_path

        # --- VALIDACIÓN DE FALLBACK ---
        # Si la busqueda profunda falló, usamos las rutas del entorno (aunque estén vacías, para no romper script)
        if not found_eigen_include: found_eigen_include = f'{env_root}/Library/include/eigen3'
        if not found_pcl_include: found_pcl_include = f'{env_root}/Library/include'
        
        # Limpieza de listas (pueden haber duplicados si buscamos en pkgs, tomamos los primeros)
        # Es sucio, pero efectivo para compilar.
        libs_pcl = list(set(libs_pcl))
        libs_cv = list(set(libs_cv))
        libs_boost = list(set(libs_boost))

        # Preparamos string para CMake
        all_libs = libs_pcl + libs_cv + libs_boost
        if lib_gdal: all_libs.append(lib_gdal)
        
        # Normalizar barras
        all_libs = [l.replace('\\\\', '/') for l in all_libs]
        libs_str = ' '.join([f'\"{l}\"' for l in all_libs])
        
        print(f'Total librerías encontradas: {len(all_libs)}')

        # --- GENERAR CMAKELISTS.TXT ---
        cmake_content = f'''
        cmake_minimum_required(VERSION 3.5)
        project(odm_orthophoto)
        set(CMAKE_CXX_STANDARD 14)
        add_definitions(-D_CRT_SECURE_NO_WARNINGS -DNOMINMAX -DBOOST_USE_WINDOWS_H)
        
        # INCLUDES DE LA BÚSQUEDA PROFUNDA
        include_directories(\"{found_eigen_include}\")
        include_directories(\"{found_pcl_include}\")
        include_directories(\"src\")
        # Añadimos rutas estandar por si acaso
        include_directories(\"{env_root}/Library/include\")
        
        add_executable(odm_orthophoto src/OdmOrthoPhoto.cpp src/Logger.cpp src/main.cpp)
        
        target_link_libraries(odm_orthophoto {libs_str})
        '''
        
        with open('CMakeLists.txt', 'w') as f:
            f.write(cmake_content)
        "

    # 4. COMPILACIÓN
    - name: Compile
      shell: bash -l {0}
      run: |
        mkdir build
        cd build
        cmake .. -G "Visual Studio 16 2019" -A x64 -DCMAKE_BUILD_TYPE=Release
        cmake --build . --config Release
        
    # 5. Subida
    - name: Upload Artifact
      uses: actions/upload-artifact@v4
      with:
        name: odm_orthophoto_exe
        path: build/Release/odm_orthophoto.exe
        compression-level: 0
