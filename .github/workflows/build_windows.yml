name: Build Windows Exe
on: [push, workflow_dispatch]

jobs:
  build:
    runs-on: windows-2019
    
    steps:
    - uses: actions/checkout@v4
    
    # 1. Instalamos Miniforge
    - name: Setup Miniforge
      uses: conda-incubator/setup-miniconda@v3
      with:
        miniforge-variant: Miniforge3
        miniforge-version: latest
        activate-environment: odm_build
        python-version: 3.9
        
    # 2. Instalamos librerías
    - name: Install Dependencies
      shell: bash -l {0}
      run: |
        mamba install -c conda-forge cmake ninja compilers gdal opencv pcl boost eigen -y

    # 3. DIAGNÓSTICO VISUAL (¡Para ver qué rayos hay ahí!)
    - name: Debug File System
      shell: bash -l {0}
      run: |
        echo "=== EXPLORANDO CARPETAS DE INCLUSIÓN ==="
        ls -F "$CONDA_PREFIX/Library/include"
        echo "========================================"
        # Verificar si existe eigen3
        if [ -d "$CONDA_PREFIX/Library/include/eigen3" ]; then
            echo "DENTRO DE EIGEN3:"
            ls -F "$CONDA_PREFIX/Library/include/eigen3"
        fi

    # 4. GENERACIÓN "ESCOPETA" (Añadir todas las rutas posibles)
    - name: Generate Config
      shell: bash -l {0}
      run: |
        python -c "
        import os
        import glob
        
        prefix = os.environ['CONDA_PREFIX'].replace('\\\\', '/')
        inc_dir = f'{prefix}/Library/include'
        lib_dir = f'{prefix}/Library/lib'
        
        # --- LISTA DE INCLUDES ---
        # Añadimos la raíz
        includes = [inc_dir, 'src']
        
        # Añadimos subcarpetas comunes de Eigen
        includes.append(f'{inc_dir}/eigen3')
        includes.append(f'{inc_dir}/Eigen')
        
        # Añadimos TODAS las carpetas de versión de PCL que encontremos
        if os.path.exists(inc_dir):
            for item in os.listdir(inc_dir):
                full_path = f'{inc_dir}/{item}'
                if os.path.isdir(full_path):
                    # Si es pcl-1.X, lo añadimos
                    if item.startswith('pcl-'):
                        print(f'Añadiendo ruta PCL: {full_path}')
                        includes.append(full_path)
        
        # Convertimos a string para CMake
        includes_str = ' '.join([f'\"{p}\"' for p in includes])
        
        # --- LISTA DE LIBRERÍAS ---
        pcl_libs = glob.glob(f'{lib_dir}/pcl_*.lib')
        cv_libs = glob.glob(f'{lib_dir}/opencv_*.lib')
        boost_libs = glob.glob(f'{lib_dir}/boost_*.lib')
        gdal_lib = f'{lib_dir}/gdal_i.lib'
        
        all_libs = pcl_libs + cv_libs + boost_libs
        # Añadimos GDAL solo si existe
        if os.path.exists(gdal_lib):
             all_libs.append(gdal_lib)
        
        all_libs = [l.replace('\\\\', '/') for l in all_libs]
        all_libs_str = ' '.join([f'\"{l}\"' for l in all_libs])
        
        print(f'Includes usados: {includes_str}')

        # --- ESCRITURA ---
        cmake_content = f'''
        cmake_minimum_required(VERSION 3.5)
        project(odm_orthophoto)
        set(CMAKE_CXX_STANDARD 14)
        
        add_definitions(-D_CRT_SECURE_NO_WARNINGS -DNOMINMAX -DBOOST_USE_WINDOWS_H)
        
        # Inyectamos TODAS las rutas posibles
        include_directories({includes_str})
        
        add_executable(odm_orthophoto src/OdmOrthoPhoto.cpp src/Logger.cpp src/main.cpp)
        
        target_link_libraries(odm_orthophoto {all_libs_str})
        '''
        
        with open('CMakeLists.txt', 'w') as f:
            f.write(cmake_content)
        "

    # 5. COMPILACIÓN
    - name: Compile
      shell: bash -l {0}
      run: |
        mkdir build
        cd build
        cmake .. -G "Visual Studio 16 2019" -A x64 -DCMAKE_BUILD_TYPE=Release
        cmake --build . --config Release
        
    # 6. Subida
    - name: Upload Artifact
      uses: actions/upload-artifact@v4
      with:
        name: odm_orthophoto_exe
        path: build/Release/odm_orthophoto.exe
        compression-level: 0
