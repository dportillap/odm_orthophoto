name: Build Windows Exe
on: [push, workflow_dispatch]

jobs:
  build:
    runs-on: windows-2019
    
    steps:
    - uses: actions/checkout@v4
    
    # 1. Instalamos Miniforge
    - name: Setup Miniforge
      uses: conda-incubator/setup-miniconda@v3
      with:
        miniforge-variant: Miniforge3
        miniforge-version: latest
        activate-environment: odm_build
        python-version: 3.9
        
    # 2. Instalamos librerías
    - name: Install Dependencies
      shell: bash -l {0}
      run: |
        mamba install -c conda-forge cmake ninja compilers gdal opencv pcl boost eigen -y

    # 3. CONSOLIDACIÓN DE ACTIVOS (Copiar todo a una carpeta local limpia)
    - name: Consolidate Libraries
      shell: bash -l {0}
      run: |
        python -c "
        import os
        import shutil
        import glob
        
        # Origen (Caos de Conda)
        src_root = os.environ['CONDA_PREFIX']
        
        # Destino (Nuestra carpeta limpia)
        dist_inc = os.path.abspath('MY_LIBS/include')
        dist_lib = os.path.abspath('MY_LIBS/lib')
        
        # Crear carpetas
        os.makedirs(dist_inc, exist_ok=True)
        os.makedirs(dist_lib, exist_ok=True)
        
        print(f'Consolidando librerías desde {src_root} hacia {dist_inc}...')
        
        # --- BUSQUEDA Y COPIA DE HEADERS ---
        eigen_found = False
        pcl_found = False
        
        for root, dirs, files in os.walk(src_root):
            # A. ARREGLAR EIGEN
            # Buscamos la carpeta que contiene 'StdVector'
            if 'StdVector' in files:
                # Si estamos en .../eigen3/Eigen, queremos copiar 'Eigen' a dist_inc/Eigen
                if root.endswith('Eigen'):
                    print(f'Copiando Eigen desde: {root}')
                    # Copiamos la carpeta 'Eigen' completa
                    target = os.path.join(dist_inc, 'Eigen')
                    if not os.path.exists(target):
                        shutil.copytree(root, target)
                        eigen_found = True

            # B. ARREGLAR PCL
            # Buscamos la carpeta que contiene 'pcl_base.h' o 'obj_io.h'
            # PCL suele estar en .../include/pcl-1.X/pcl. Queremos copiar 'pcl' a dist_inc/pcl
            if 'pcl_base.h' in files:
                if root.endswith('pcl'): # Aseguramos que sea la carpeta raíz 'pcl'
                    print(f'Copiando PCL desde: {root}')
                    target = os.path.join(dist_inc, 'pcl')
                    if not os.path.exists(target):
                        shutil.copytree(root, target)
                        pcl_found = True
            
            # C. COPIAR LIBRERÍAS (.LIB)
            for f in files:
                if f.endswith('.lib'):
                    # Filtramos solo las que nos interesan
                    if any(x in f for x in ['pcl_', 'opencv_', 'boost_', 'gdal_i']):
                        src_file = os.path.join(root, f)
                        dst_file = os.path.join(dist_lib, f)
                        shutil.copy2(src_file, dst_file)

        if not eigen_found:
            print('ERROR: No se encontró Eigen para copiar. Intentando fallback...')
            # Fallback ciego
            fallback = os.path.join(src_root, 'Library/include/eigen3/Eigen')
            if os.path.exists(fallback):
                 shutil.copytree(fallback, os.path.join(dist_inc, 'Eigen'))

        print('--- Contenido de MY_LIBS/include ---')
        print(os.listdir(dist_inc))
        
        # --- GENERAR CMAKELISTS.TXT ---
        # Ahora es muy fácil porque sabemos EXACTAMENTE dónde está todo
        cmake_content = f'''
        cmake_minimum_required(VERSION 3.5)
        project(odm_orthophoto)
        set(CMAKE_CXX_STANDARD 14)
        add_definitions(-D_CRT_SECURE_NO_WARNINGS -DNOMINMAX -DBOOST_USE_WINDOWS_H)
        
        # Solo necesitamos incluir NUESTRA carpeta
        include_directories(\"{dist_inc.replace(os.sep, '/')}\")
        include_directories(\"src\")
        
        # Agarrar todas las libs que copiamos
        file(GLOB ALL_LIBS \"{dist_lib.replace(os.sep, '/')}/*.lib\")
        
        add_executable(odm_orthophoto src/OdmOrthoPhoto.cpp src/Logger.cpp src/main.cpp)
        
        target_link_libraries(odm_orthophoto \${{ALL_LIBS}})
        '''
        
        with open('CMakeLists.txt', 'w') as f:
            f.write(cmake_content)
        "

    # 4. COMPILACIÓN
    - name: Compile
      shell: bash -l {0}
      run: |
        mkdir build
        cd build
        cmake .. -G "Visual Studio 16 2019" -A x64 -DCMAKE_BUILD_TYPE=Release
        cmake --build . --config Release
        
    # 5. Subida
    - name: Upload Artifact
      uses: actions/upload-artifact@v4
      with:
        name: odm_orthophoto_exe
        path: build/Release/odm_orthophoto.exe
        compression-level: 0
