name: Build Windows Exe
on: [push, workflow_dispatch]

jobs:
  build:
    runs-on: windows-2019
    
    steps:
    - uses: actions/checkout@v4
    
    # 1. Instalamos Miniforge
    - name: Setup Miniforge
      uses: conda-incubator/setup-miniconda@v3
      with:
        miniforge-variant: Miniforge3
        miniforge-version: latest
        activate-environment: odm_build
        python-version: 3.9
        
    # 2. Instalamos librerías
    - name: Install Dependencies
      shell: bash -l {0}
      run: |
        mamba install -c conda-forge cmake ninja compilers gdal opencv pcl boost eigen -y

    # 3. EL ESCÁNER TOTAL (Búsqueda recursiva profunda)
    - name: Recursive Scan and Generate
      shell: bash -l {0}
      run: |
        python -c "
        import os
        
        # Normalizar rutas
        base_dir = os.environ['CONDA_PREFIX'].replace('\\\\', '/')
        print(f'Escaner iniciado en: {base_dir}')
        
        # Variables para almacenar rutas
        pcl_inc = None
        eigen_inc = None
        
        libs_pcl = []
        libs_cv = []
        libs_boost = []
        lib_gdal = None
        
        # --- RECORRIDO DE TODO EL ARBOL DE CARPETAS ---
        for root, dirs, files in os.walk(base_dir):
            root_norm = root.replace('\\\\', '/')
            
            # A. BUSQUEDA DE HEADERS (ARCHIVOS CLAVE)
            
            # 1. PCL: Buscamos 'obj_io.h'
            # Suele estar en .../include/pcl-1.X/pcl/io/obj_io.h
            if 'obj_io.h' in files and pcl_inc is None:
                # Si lo encontramos, subimos 2 niveles para obtener la raíz del include
                if root_norm.endswith('/pcl/io'):
                    pcl_inc = root_norm.rsplit('/pcl/io', 1)[0]
                    print(f'¡ENCONTRADO HEADER PCL! -> {pcl_inc}')

            # 2. Eigen: Buscamos 'StdVector'
            # Suele estar en .../include/eigen3/Eigen/StdVector
            if 'StdVector' in files and eigen_inc is None:
                 if root_norm.endswith('/Eigen'):
                    eigen_inc = root_norm.rsplit('/Eigen', 1)[0]
                    print(f'¡ENCONTRADO HEADER EIGEN! -> {eigen_inc}')
            
            # B. BUSQUEDA DE LIBRERIAS (.lib)
            for f in files:
                if f.endswith('.lib'):
                    full_path = f'{root_norm}/{f}'
                    
                    if f.startswith('pcl_') and not f.endswith('d.lib'): # Evitamos debug libs si hay
                        libs_pcl.append(full_path)
                    elif f.startswith('opencv_') and not f.endswith('d.lib'):
                        libs_cv.append(full_path)
                    elif f.startswith('boost_') and not f.endswith('d.lib'):
                        libs_boost.append(full_path)
                    elif f == 'gdal_i.lib':
                        lib_gdal = full_path

        # --- VALIDACIÓN ---
        if not pcl_inc:
            print('ERROR CRITICO: No encontré headers de PCL. Usando fallback arriesgado.')
            pcl_inc = f'{base_dir}/Library/include'
        if not eigen_inc:
             print('ERROR CRITICO: No encontré headers de Eigen. Usando fallback.')
             eigen_inc = f'{base_dir}/Library/include/eigen3'

        print(f'Total PCL Libs: {len(libs_pcl)}')
        print(f'Total OpenCV Libs: {len(libs_cv)}')
        
        # Preparamos las listas para CMake (con comillas)
        all_libs = libs_pcl + libs_cv + libs_boost
        if lib_gdal:
            all_libs.append(lib_gdal)
        
        libs_str = ' '.join([f'\"{l}\"' for l in all_libs])

        # --- GENERAR CMAKELISTS.TXT ---
        cmake_content = f'''
        cmake_minimum_required(VERSION 3.5)
        project(odm_orthophoto)
        set(CMAKE_CXX_STANDARD 14)
        
        add_definitions(-D_CRT_SECURE_NO_WARNINGS -DNOMINMAX -DBOOST_USE_WINDOWS_H)
        
        # Rutas detectadas
        include_directories(\"{pcl_inc}\")
        include_directories(\"{eigen_inc}\")
        # Siempre incluimos la raiz por si acaso
        include_directories(\"{base_dir}/Library/include\")
        include_directories(\"src\")
        
        add_executable(odm_orthophoto src/OdmOrthoPhoto.cpp src/Logger.cpp src/main.cpp)
        
        # Enlazamos las librerías encontradas
        target_link_libraries(odm_orthophoto {libs_str})
        '''
        
        with open('CMakeLists.txt', 'w') as f:
            f.write(cmake_content)
            
        print('--- CMakeLists.txt generado ---')
        "

    # 4. COMPILACIÓN
    - name: Compile
      shell: bash -l {0}
      run: |
        mkdir build
        cd build
        cmake .. -G "Visual Studio 16 2019" -A x64 -DCMAKE_BUILD_TYPE=Release
        cmake --build . --config Release
        
    # 5. Subida
    - name: Upload Artifact
      uses: actions/upload-artifact@v4
      with:
        name: odm_orthophoto_exe
        path: build/Release/odm_orthophoto.exe
        compression-level: 0
