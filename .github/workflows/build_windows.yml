name: Build Windows Exe
on: [push, workflow_dispatch]

jobs:
  build:
    runs-on: windows-2019
    
    steps:
    - uses: actions/checkout@v4
    
    # 1. Instalamos Miniforge (MODO SILENCIOSO)
    - name: Setup Miniforge
      uses: conda-incubator/setup-miniconda@v3
      with:
        miniforge-variant: Miniforge3
        miniforge-version: latest
        activate-environment: ""
        auto-activate-base: true
        
    # 2. Instalamos librerías
    - name: Install Dependencies
      shell: bash -l {0}
      run: |
        mamba install -n base -c conda-forge cmake ninja compilers gdal opencv pcl boost eigen -y

    # 3. CIRUGÍA DE CARPETAS (Boost + OpenCV + PCL + Eigen)
    - name: Surgical Consolidate
      shell: bash -l {0}
      run: |
        python -c "
        import os
        import shutil
        import glob
        
        # Origen y Destino
        if 'CONDA_PREFIX' in os.environ:
            src_root = os.environ['CONDA_PREFIX']
        else:
            src_root = 'C:/Users/runneradmin/miniconda3'
            
        dist_inc = os.path.abspath('MY_LIBS/include')
        dist_lib = os.path.abspath('MY_LIBS/lib')
        
        # Limpiar y crear destino
        if os.path.exists('MY_LIBS'):
            shutil.rmtree('MY_LIBS')
        os.makedirs(dist_inc)
        os.makedirs(dist_lib)
        
        print(f'Buscando tesoros en: {src_root}')
        
        # --- 1. EIGEN ---
        eigen_found = False
        for root, dirs, files in os.walk(src_root):
            if 'StdVector' in files and root.endswith('Eigen'):
                target = os.path.join(dist_inc, 'Eigen')
                if not os.path.exists(target):
                    print(f'Copiando Eigen desde: {root}')
                    shutil.copytree(root, target)
                    eigen_found = True
                    break 
        if not eigen_found:
             # Fallback típico
             fb = os.path.join(src_root, 'Library/include/eigen3/Eigen')
             if os.path.exists(fb): shutil.copytree(fb, os.path.join(dist_inc, 'Eigen'))

        # --- 2. PCL ---
        for root, dirs, files in os.walk(src_root):
            if 'pcl_base.h' in files:
                path_parts = root.replace('\\\\', '/').split('/')
                if path_parts[-1] == 'pcl':
                    target = os.path.join(dist_inc, 'pcl')
                    if not os.path.exists(target):
                        print(f'Copiando PCL desde: {root}')
                        shutil.copytree(root, target)
                        break

        # --- 3. BOOST (NUEVO) ---
        # Boost suele estar en Library/include/boost
        boost_src = os.path.join(src_root, 'Library/include/boost')
        boost_target = os.path.join(dist_inc, 'boost')
        
        if os.path.exists(boost_src):
            print(f'Copiando Boost desde: {boost_src}')
            shutil.copytree(boost_src, boost_target)
        else:
            print('WARN: No encontré Boost en ruta estándar. Buscando...')
            for root, dirs, files in os.walk(src_root):
                if 'version.hpp' in files and root.endswith('boost'):
                     if not os.path.exists(boost_target):
                         print(f'Boost encontrado en: {root}')
                         shutil.copytree(root, boost_target)
                         break

        # --- 4. OPENCV (NUEVO - Preventivo) ---
        # OpenCV suele estar en Library/include/opencv2
        cv_src = os.path.join(src_root, 'Library/include/opencv2')
        cv_target = os.path.join(dist_inc, 'opencv2')
        
        if os.path.exists(cv_src):
            print(f'Copiando OpenCV desde: {cv_src}')
            shutil.copytree(cv_src, cv_target)
        else:
             # Búsqueda manual si falla la estándar
             for root, dirs, files in os.walk(src_root):
                if 'core.hpp' in files and root.endswith('opencv2'): # core.hpp es clave en opencv2
                     if not os.path.exists(cv_target):
                         print(f'OpenCV encontrado en: {root}')
                         shutil.copytree(root, cv_target)
                         break

        # --- 5. LIBRERÍAS .LIB ---
        count_libs = 0
        for root, dirs, files in os.walk(src_root):
            for f in files:
                if f.endswith('.lib'):
                    if any(x in f for x in ['pcl_', 'opencv_', 'boost_', 'gdal_i']):
                        try:
                            shutil.copy2(os.path.join(root, f), os.path.join(dist_lib, f))
                            count_libs += 1
                        except: pass
        print(f'-> {count_libs} librerías .lib copiadas.')

        # --- VERIFICACIÓN ---
        print('\n--- MY_LIBS/include contiene: ---')
        if os.path.exists(dist_inc):
            print(os.listdir(dist_inc))

        # --- GENERAR CMAKELISTS.TXT ---
        inc_str = dist_inc.replace(os.sep, '/')
        lib_str = dist_lib.replace(os.sep, '/') + '/*.lib'
        var_start = '$' + '{ALL_LIBS}'
        
        cmake_txt = f'''
        cmake_minimum_required(VERSION 3.5)
        project(odm_orthophoto)
        set(CMAKE_CXX_STANDARD 14)
        add_definitions(-D_CRT_SECURE_NO_WARNINGS -DNOMINMAX -DBOOST_USE_WINDOWS_H)
        
        # Incluimos nuestra carpeta consolidada
        include_directories(\"{inc_str}\")
        include_directories(\"src\")
        
        file(GLOB ALL_LIBS \"{lib_str}\")
        
        add_executable(odm_orthophoto src/OdmOrthoPhoto.cpp src/Logger.cpp src/main.cpp)
        
        target_link_libraries(odm_orthophoto {var_start})
        '''
        
        with open('CMakeLists.txt', 'w') as f:
            f.write(cmake_txt)
        "

    # 4. COMPILACIÓN
    - name: Compile
      shell: bash -l {0}
      run: |
        mkdir build
        cd build
        cmake .. -G "Visual Studio 16 2019" -A x64 -DCMAKE_BUILD_TYPE=Release
        cmake --build . --config Release
        
    # 5. Subida
    - name: Upload Artifact
      uses: actions/upload-artifact@v4
      with:
        name: odm_orthophoto_exe
        path: build/Release/odm_orthophoto.exe
        compression-level: 0
